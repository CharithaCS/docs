"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[350],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(n),m=l,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(k,i(i({ref:t},c),{},{components:n})):a.createElement(k,i({ref:t},c))}));function m(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:l,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),l=n(6010);const r="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,l.Z)(r,i),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>m});var a=n(7462),l=n(7294),r=n(6010),i=n(2389),o=n(7392),s=n(7094),p=n(2466);const c="tabList__CuJ",u="tabItem_LNqP";function d(e){var t,n;const{lazy:i,block:d,defaultValue:m,values:k,groupId:h,className:f}=e,g=l.Children.map(e.children,(e=>{if((0,l.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=k?k:g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),b=(0,o.l)(v,((e,t)=>e.value===t.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const y=null===m?m:null!=(t=null!=m?m:null==(n=g.find((e=>e.props.default)))?void 0:n.props.value)?t:g[0].props.value;if(null!==y&&!v.some((e=>e.value===y)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+v.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:w,setTabGroupChoices:N}=(0,s.U)(),[T,z]=(0,l.useState)(y),x=[],{blockElementScrollPositionUntilNextRender:C}=(0,p.o5)();if(null!=h){const e=w[h];null!=e&&e!==T&&v.some((t=>t.value===e))&&z(e)}const O=e=>{const t=e.currentTarget,n=x.indexOf(t),a=v[n].value;a!==T&&(C(t),z(a),null!=h&&N(h,String(a)))},S=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=x.indexOf(e.currentTarget)+1;n=null!=(a=x[t])?a:x[0];break}case"ArrowLeft":{var l;const t=x.indexOf(e.currentTarget)-1;n=null!=(l=x[t])?l:x[x.length-1];break}}null==(t=n)||t.focus()};return l.createElement("div",{className:(0,r.Z)("tabs-container",c)},l.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":d},f)},v.map((e=>{let{value:t,label:n,attributes:i}=e;return l.createElement("li",(0,a.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:e=>x.push(e),onKeyDown:S,onFocus:O,onClick:O},i,{className:(0,r.Z)("tabs__item",u,null==i?void 0:i.className,{"tabs__item--active":T===t})}),null!=n?n:t)}))),i?(0,l.cloneElement)(g.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):l.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,l.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function m(e){const t=(0,i.Z)();return l.createElement(d,(0,a.Z)({key:String(t)},e))}},1588:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>u});var a=n(7462),l=(n(7294),n(3905)),r=n(5488),i=n(5162);const o={sidebar_position:3,title:"IBAC via network policies"},s=void 0,p={unversionedId:"documentation/guides/ibac-via-network-policies",id:"documentation/guides/ibac-via-network-policies",title:"IBAC via network policies",description:"Recap: K8s network policies and CNI network plugins",source:"@site/docs/documentation/3-guides/3-ibac-via-network-policies.md",sourceDirName:"documentation/3-guides",slug:"/documentation/guides/ibac-via-network-policies",permalink:"/documentation/guides/ibac-via-network-policies",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/documentation/3-guides/3-ibac-via-network-policies.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"IBAC via network policies"},sidebar:"docSidebar",previous:{title:"Mapping pod-to-pod calls",permalink:"/documentation/guides/mapping-pod-to-pod-calls"},next:{title:"Terminology",permalink:"/documentation/concepts/terminology"}},c={},u=[{value:"Recap: K8s network policies and CNI network plugins",id:"recap-k8s-network-policies-and-cni-network-plugins",level:2},{value:"Setting security scope via default network policies",id:"setting-security-scope-via-default-network-policies",level:3},{value:"Deep dive - how intents translate to network policies.",id:"deep-dive---how-intents-translate-to-network-policies",level:2},{value:"Deploy example",id:"deploy-example",level:3},{value:"Track artifacts",id:"track-artifacts",level:3},{value:"\u2026",id:"",level:2},{value:"Practical notes",id:"practical-notes",level:2},{value:"Avoiding drift",id:"avoiding-drift",level:3},{value:"Avoiding blocking of essential services",id:"avoiding-blocking-of-essential-services",level:3}],d={toc:u};function m(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"recap-k8s-network-policies-and-cni-network-plugins"},"Recap: K8s network policies and CNI network plugins"),(0,l.kt)("p",null,(0,l.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/"},"Network policies")," are one of the tools we\ncan use for traffic shaping within K8s clusters. They allow us to shape traffic using selectors, policies, and L3\nand L4 identifiers. To enforce network policies, a Kubernetes cluster requires a CNI supporting network policies to be\ninstalled. Some popular options are Calico and Cilium."),(0,l.kt)("p",null,"Let's take a look at an example showing a network policy allowing traffic"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"from")," pods labeled ",(0,l.kt)("inlineCode",{parentName:"li"},"app:backend")," belonging to namespaces labeled ",(0,l.kt)("inlineCode",{parentName:"li"},"env:production")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("em",{parentName:"li"},"to")," pods labeled ",(0,l.kt)("inlineCode",{parentName:"li"},"app:db")," in the namespace  ",(0,l.kt)("inlineCode",{parentName:"li"},"production-db"))),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-production-backend\n  # highlight-next-line\n  namespace: production-db            # [Target filter] Policy applies to target pods in this namespace\nspec:\n  podSelector:\n    matchLabels:\n      # highlight-next-line\n      app: db                         # [Target filter] Policy applies to target pods with this label\n  policyTypes:\n    # highlight-next-line\n    - Ingress                         # [Direction] Policy implemented as a filter on incoming connections\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              # highlight-next-line\n              env: production         # [Source filter] Policy filters source pods from namespaces with this label\n        - podSelector:\n            matchLabels:\n              # highlight-next-line\n              app: backend            # [Source filter] Policy filters source pods from with this label\n")),(0,l.kt)("h3",{id:"setting-security-scope-via-default-network-policies"},"Setting security scope via default network policies"),(0,l.kt)("p",null,"Two common approaches for working with network policies are"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Allow all traffic between pods, protect some pods by applying ingress network policies to them."),(0,l.kt)("li",{parentName:"ul"},"Block all traffic between pods except allowed traffic by network policies.")),(0,l.kt)("p",null,"Note"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Applying an ingress network policy to a pod will automatically block all communications to it except those allowed by\nnetwork policies."),(0,l.kt)("li",{parentName:"ul"},"You can apply both approaches (allow/block all) within your cluster (e.g. by applying network policies based on\nnamespaces).")),(0,l.kt)("p",null,"To block all traffic within a namespace (e.g. ",(0,l.kt)("em",{parentName:"p"},"production"),") you can apply a default deny network policy like the\nfollowing example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny-ingress\n  namespace: production\nspec:\n  podSelector: { }\n  policyTypes:\n    - Ingress\n")),(0,l.kt)("h2",{id:"deep-dive---how-intents-translate-to-network-policies"},"Deep dive - how intents translate to network policies."),(0,l.kt)("p",null,"Let's follow an example scenario and track how Otterize configures network policies when we apply intents."),(0,l.kt)("h3",{id:"deploy-example"},"Deploy example"),(0,l.kt)("p",null,"Our simple example consists of two pods: an HTTP server and a client that calls it. We also deploy a default-deny ingress network policy,\nblocking pods from accepting incoming calls unless another network policy explicitly allows them."),(0,l.kt)(r.Z,{mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"namespace.yaml",label:"namespace.yaml",default:!0,mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Namespace\nmetadata:\nname: otterize-tutorial-npol\n"))),(0,l.kt)(i.Z,{value:"server.yaml",label:"server.yaml",default:!0,mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: server\nnamespace:  otterize-tutorial-npol\nspec:\nselector:\n matchLabels:\n   app: server\ntemplate:\n metadata:\n   labels:\n     app: server\n spec:\n   containers:\n     - name: server\n       image: hashicorp/http-echo\n       args: [ "-listen=:80", "-text=Hi, I am the server, you called, may I help you?"]\n---\napiVersion: v1\nkind: Service\nmetadata:\nname: server\nnamespace:  otterize-tutorial-npol\nspec:\nselector:\n app: server\nports:\n - protocol: TCP\n   port: 80\n   targetPort: 80\n'))),(0,l.kt)(i.Z,{value:"client.yaml",label:"client.yaml",default:!0,mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: client\nnamespace:  otterize-tutorial-npol\nspec:\nselector:\n matchLabels:\n   app: client\ntemplate:\n metadata:\n   labels:\n     app: client\n spec:\n   containers:\n     - name: client\n       image: alpine/curl\n       command: [ "/bin/sh", "-c", "--" ]\n       args: [ "while true; do echo \\"Calling server...\\"; if ! timeout 2 curl -si server 2>/dev/null; then echo \\"curl timed out\\"; fi; sleep 2; done" ]\n'))),(0,l.kt)(i.Z,{value:"default-deny.yaml",label:"default-deny.yaml",default:!0,mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\nname: default-deny-ingress\nnamespace:  otterize-tutorial-npol\nspec:\npodSelector: {}\npolicyTypes:\n - Ingress\n")))),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Deploy the client, server, and the default deny network policy using ",(0,l.kt)("inlineCode",{parentName:"p"},"kubectl"),"."),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl apply -f https://docs.otterize.com/code-examples/network-policies/all.yaml\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"Check that the ",(0,l.kt)("inlineCode",{parentName:"p"},"client")," and server ",(0,l.kt)("inlineCode",{parentName:"p"},"pods")," were deployed"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -n otterize-tutorial-npol\n")),(0,l.kt)("p",{parentName:"li"},"You should see"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre"},"NAME                      READY   STATUS    RESTARTS   AGE\nclient-5689997b5c-grlnt   1/1     Running   0          35s\nserver-6698c58cbc-v9n9b   1/1     Running   0          34s\n"))),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("p",{parentName:"li"},"The client intents to call the server are declared with this ",(0,l.kt)("inlineCode",{parentName:"p"},"intents.yaml")," file:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: k8s.otterize.com/v1alpha1\nkind: ClientIntents\nmetadata:\nname: client\nnamespace:  otterize-tutorial-npol\nspec:\nservice:\n name: client\ncalls:\n - name: server\n   type: HTTP\n")),(0,l.kt)("p",{parentName:"li"},"   Let's apply it:"),(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-shell"},"kubectl apply -f https://docs.otterize.com/code-examples/network-policies/intents.yaml\n")))),(0,l.kt)("h3",{id:"track-artifacts"},"Track artifacts"),(0,l.kt)("p",null,"After applying the intents file Otterize generated multiple artifacts to configure access from the client to\nserver via network policies:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A network policy allowing traffic from the ","[client, namespace -labeled]"," pods to ","[server-labeled]"," pods"),(0,l.kt)("li",{parentName:"ul"},"Create label and apply it to the client pod"),(0,l.kt)("li",{parentName:"ul"},"Create label and apply it to the server pod"),(0,l.kt)("li",{parentName:"ul"},"Create label and apply it to the client pod's namespace")),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Let's look at the network policy",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl describe networkpolicies -n otterize-tutorial-npol access-to-server-from-otterize-tutorial-npol\n")),"You should see",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-yaml"},"Name:         access-to-server-from-otterize-tutorial-npol\nNamespace:    otterize-tutorial-npol                                          # [Target filter] namespace\nCreated on:   2022-09-08 19:12:24 +0300 IDT\nLabels:       otterize/network-policy=true\nAnnotations:  <none>\nSpec:\n  PodSelector:     otterize/server=server-otterize-tutorial-np-7e16db         # [Target filter] pods with this label\n  Allowing ingress traffic:\n    To Port: <any> (traffic allowed to all ports)\n    From:\n      NamespaceSelector: otterize/namespace-name=otterize-tutorial-npol       # [Source filter] namespaces with this label\n      PodSelector: otterize/access-server-otterize-tutorial-np-7e16db=true    # [Source filter] pods with this label\n  Not affecting egress traffic\n  Policy Types: Ingress                                                       # [Direction]\n"))),(0,l.kt)("li",{parentName:"ol"},"And we can see that the client and server pods are labeled",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -n otterize-tutorial-npol --show-labels\n")),"You should see",(0,l.kt)("pre",{parentName:"li"},(0,l.kt)("code",{parentName:"pre",className:"language-bash"},"NAME                      READY   STATUS    RESTARTS   AGE   LABELS\nclient-5cb67b748-zxkxj    1/1     Running   0          28h   app=client,otterize/access-server-otterize-tutorial-np-7e16db=true,otterize/client=true,otterize/server=client-otterize-tutorial-np-699302,otterize/spire-integration-operator.service-name=client,pod-template-hash=5cb67b748\nserver-564b56f596-cl4gl   1/1     Running   0          28h   app=server,otterize/server=server-otterize-tutorial-np-7e16db,otterize/spire-integration-operator.service-name=server,pod-template-hash=564b56f596\n")))),(0,l.kt)("p",null,"The key labels are"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"For the server - otterize/server=server-otterize-tutorial-np-7e16db"),(0,l.kt)("li",{parentName:"ul"},"For the client - otterize/access-server-otterize-tutorial-np-7e16db=true")),(0,l.kt)("p",null,"The naming convention is that target pods are labeled with"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"otterize/server=             # prefix for target pods"),(0,l.kt)("li",{parentName:"ul"},"server-otterize-tutorial-np- # target {pod inferred name}-{pod namespace} truncated"),(0,l.kt)("li",{parentName:"ul"},"7e16db                       # a hash over both attributes (name, namespace)")),(0,l.kt)("p",null,"And source pods are labeled with"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"otterize/access-             # prefix for source pods"),(0,l.kt)("li",{parentName:"ul"},"server-otterize-tutorial-np- # target {pod inferred name}-{pod namespace} truncated"),(0,l.kt)("li",{parentName:"ul"},"7e16db                       # a hash over both attributes (name, namespace)"),(0,l.kt)("li",{parentName:"ul"},"=true                        # marker for ",(0,l.kt)("strong",{parentName:"li"},"allowed")," access")),(0,l.kt)("h2",{id:""},"\u2026"),(0,l.kt)("h2",{id:"practical-notes"},"Practical notes"),(0,l.kt)("h3",{id:"avoiding-drift"},"Avoiding drift"),(0,l.kt)("h3",{id:"avoiding-blocking-of-essential-services"},"Avoiding blocking of essential services"),(0,l.kt)("p",null,"Otterize automatically generates network policies, when needed, to allow load balancers, ingresses and other XXX to\ncommunicate with their intended targets within the cluster.\nThink of the following scenario"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"There's an internet facing load balancer calling the frontend service"),(0,l.kt)("li",{parentName:"ul"},"There's an internal load generator service also calling the frontend service"),(0,l.kt)("li",{parentName:"ul"},"The user created an intents file with an intent to call the frontend service from the load generator service"),(0,l.kt)("li",{parentName:"ul"},"Otterize will then generate a network policy for ","[load generator service->frontend service]"),(0,l.kt)("li",{parentName:"ul"},"That network policy will block traffic from the load balancer unless we take action"),(0,l.kt)("li",{parentName:"ul"},"That is why Otterize will also identify this case and generate another network policy to allow traffic from the load\nbalancer to the frontend.")))}m.isMDXComponent=!0}}]);