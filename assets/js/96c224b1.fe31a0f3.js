"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[279],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>h});var i=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,i)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,i,n=function(e,t){if(null==e)return{};var r,i,n={},o=Object.keys(e);for(i=0;i<o.length;i++)r=o[i],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)r=o[i],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=i.createContext({}),c=function(e){var t=i.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),u=c(r),h=n,m=u["".concat(l,".").concat(h)]||u[h]||p[h]||o;return r?i.createElement(m,s(s({ref:t},d),{},{components:r})):i.createElement(m,s({ref:t},d))}));function h(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=u;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:n,s[1]=a;for(var c=2;c<o;c++)s[c]=r[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,r)}u.displayName="MDXCreateElement"},9955:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var i=r(7462),n=(r(7294),r(3905));const o={sidebar_position:9,title:"Service identities and resolution"},s=void 0,a={unversionedId:"service-identities/README",id:"service-identities/README",title:"Service identities and resolution",description:"Otterize uses universal service identities, that are used by all Otterize components to refer to",source:"@site/docs/service-identities/README.mdx",sourceDirName:"service-identities",slug:"/service-identities/",permalink:"/service-identities/",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/service-identities/README.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9,title:"Service identities and resolution"},sidebar:"docSidebar",previous:{title:"Otterize OSS",permalink:"/otterize-oss/"},next:{title:"Kubernetes mTLS with Otterize",permalink:"/k8s-mtls/"}},l={},c=[{value:"Kubernetes service identity resolution",id:"kubernetes-service-identity-resolution",level:2}],d={toc:c};function p(e){let{components:t,...r}=e;return(0,n.kt)("wrapper",(0,i.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Otterize uses universal service identities, that are used by all Otterize components to refer to\nservices, regardless of which infrastructure they run on. Every service has a name which is specified in Otterize client intents to request access to other services."),(0,n.kt)("h2",{id:"kubernetes-service-identity-resolution"},"Kubernetes service identity resolution"),(0,n.kt)("p",null,"How do Otterize operators decide what is the name of the service that runs within the pod? The algorithm is as follows:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"If the pod has an ",(0,n.kt)("inlineCode",{parentName:"li"},"otterize/service-name")," label, its value is used as the service name. This allows developers and\nautomations to explicitly name services, if needed."),(0,n.kt)("li",{parentName:"ol"},"If there is no ",(0,n.kt)("inlineCode",{parentName:"li"},"otterize/service-name")," label, a recursive look up is performed for the Kubernetes resource owner of\nthe pod, until the root resource is reached, and its name is used as the service name. For example, if you have\na ",(0,n.kt)("inlineCode",{parentName:"li"},"Deployment")," named ",(0,n.kt)("inlineCode",{parentName:"li"},"checkoutservice"),", which then creates and owns a ",(0,n.kt)("inlineCode",{parentName:"li"},"ReplicaSet"),", which then creates and owns\na ",(0,n.kt)("inlineCode",{parentName:"li"},"Pod"),", then the service name for that pod is ",(0,n.kt)("inlineCode",{parentName:"li"},"checkoutservice")," - same as the name of the ",(0,n.kt)("inlineCode",{parentName:"li"},"Deployment"),'. This is\nintended to capture the likely-more-meaningful "human name" of the service.')),(0,n.kt)("p",null,"Pods are then labeled with values derived from service names. For example,\nthe service name is combined with the namespace of the pod and hashed to form the value of the label ",(0,n.kt)("inlineCode",{parentName:"p"},"otterize/server"),".\nThis label is then used as a selector for network policies. Another\nlabel, ",(0,n.kt)("inlineCode",{parentName:"p"},"otterize/access-server-<servicename>-<servicehash>"),", is applied to client pods which have declared their intent\nto access the server. This label is used as the selector to determine which client pods are allowed to access the server\npod."))}p.isMDXComponent=!0}}]);