"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[14],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,f=d["".concat(l,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(f,a(a({ref:t},u),{},{components:n})):r.createElement(f,a({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},481:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const i={sidebar_position:5,title:"Terminology"},a=void 0,s={unversionedId:"terminology/README",id:"terminology/README",title:"Terminology",description:"An overview of the terminology used in Otterize OSS documentation.",source:"@site/docs/4-terminology/README.mdx",sourceDirName:"4-terminology",slug:"/terminology/",permalink:"/terminology/",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/4-terminology/README.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Terminology"},sidebar:"docSidebar",previous:{title:"Kubernetes mTLS with Otterize",permalink:"/guides/k8s-mtls/"},next:{title:"IBAC: Intent-based access control",permalink:"/intent-based-access-control/"}},l={},c=[{value:"Basics",id:"basics",level:2},{value:"Service",id:"service",level:3},{value:"CLI",id:"cli",level:3},{value:"Identity",id:"identity",level:2},{value:"PKI",id:"pki",level:3},{value:"mTLS",id:"mtls",level:3},{value:"Enforcement",id:"enforcement",level:2},{value:"Network Policies",id:"network-policies",level:3},{value:"Kafka ACLs",id:"kafka-acls",level:3}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"An overview of the terminology used in Otterize OSS documentation.\nIf you think a term is missing here, please ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/otterize/docs/issues/new"},"let us know"),"."),(0,o.kt)("h2",{id:"basics"},"Basics"),(0,o.kt)("h3",{id:"service"},"Service"),(0,o.kt)("p",null,"An Otterize service is either a client or a server, and is referred to by client intents. ",(0,o.kt)("a",{parentName:"p",href:"/service-identities"},"Learn how service identity resolution happens"),"."),(0,o.kt)("h3",{id:"cli"},"CLI"),(0,o.kt)("p",null,"The Otterize CLI is a command-line utility used to control and interact with the Otterize network mapper, manipulate local Intents files, and (coming soon!) interact with Otterize Cloud."),(0,o.kt)("h2",{id:"identity"},"Identity"),(0,o.kt)("h3",{id:"pki"},"PKI"),(0,o.kt)("p",null,"PKI stands for public key infrastructure, and refers to the infrastructure used to provision X.509 credentials.\nA common use case for PKI is to support mTLS."),(0,o.kt)("h3",{id:"mtls"},"mTLS"),(0,o.kt)("p",null,"mTLS stands for mutual TLS, and is a form of TLS where both the client and server mutually authenticate to each other.\nIn other words, mTLS is mutual TLS."),(0,o.kt)("p",null,"In regular TLS, only the server is authenticated. For example, when you connect to google.com, a\nnd your browser authenticates google.com using its certificate, you're using TLS;\nbut google.com does not authenticate you, as the client, with a certificate, so the communication isn't using mTLS, just TLS."),(0,o.kt)("h2",{id:"enforcement"},"Enforcement"),(0,o.kt)("h3",{id:"network-policies"},"Network Policies"),(0,o.kt)("p",null,"Kubernetes network policies can be used to control network access between pods in a Kubernetes cluster.\nTo do so they require the installation of a Kubernetes CNI network plugin that supports network policy enforcement.\nOne commonly supported CNI is Calico.\n",(0,o.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/"},"Read more about network policies in the official documentation"),"."),(0,o.kt)("h3",{id:"kafka-acls"},"Kafka ACLs"),(0,o.kt)("p",null,"ACLs stand for Access Control Lists, a built-in mechanism in Kafka (and other systems) for authorizing access\nto Kafka resources such as topics.\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.confluent.io/platform/current/kafka/authorization.html#authorization-using-acls"},"Read more about Kafka ACLs in the official documentation"),"."))}p.isMDXComponent=!0}}]);