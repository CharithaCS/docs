"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[529],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,k=u["".concat(s,".").concat(d)]||u[d]||p[d]||l;return n?a.createElement(k,i(i({ref:t},m),{},{components:n})):a.createElement(k,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var c=2;c<l;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(7294),r=n(6010);const l="tabItem_Ymn6";function i(e){let{children:t,hidden:n,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(l,i),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>d});var a=n(7462),r=n(7294),l=n(6010),i=n(2389),o=n(7392),s=n(7094),c=n(2466);const m="tabList__CuJ",p="tabItem_LNqP";function u(e){var t,n;const{lazy:i,block:u,defaultValue:d,values:k,groupId:f,className:h}=e,g=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=k?k:g.map((e=>{let{props:{value:t,label:n,attributes:a}}=e;return{value:t,label:n,attributes:a}})),b=(0,o.l)(y,((e,t)=>e.value===t.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const N=null===d?d:null!=(t=null!=d?d:null==(n=g.find((e=>e.props.default)))?void 0:n.props.value)?t:g[0].props.value;if(null!==N&&!y.some((e=>e.value===N)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+N+'" but none of its children has the corresponding value. Available values are: '+y.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:v,setTabGroupChoices:w}=(0,s.U)(),[C,S]=(0,r.useState)(N),T=[],{blockElementScrollPositionUntilNextRender:z}=(0,c.o5)();if(null!=f){const e=v[f];null!=e&&e!==C&&y.some((t=>t.value===e))&&S(e)}const L=e=>{const t=e.currentTarget,n=T.indexOf(t),a=y[n].value;a!==C&&(z(t),S(a),null!=f&&w(f,String(a)))},P=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var a;const t=T.indexOf(e.currentTarget)+1;n=null!=(a=T[t])?a:T[0];break}case"ArrowLeft":{var r;const t=T.indexOf(e.currentTarget)-1;n=null!=(r=T[t])?r:T[T.length-1];break}}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,l.Z)("tabs-container",m)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":u},h)},y.map((e=>{let{value:t,label:n,attributes:i}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:e=>T.push(e),onKeyDown:P,onFocus:L,onClick:L},i,{className:(0,l.Z)("tabs__item",p,null==i?void 0:i.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),i?(0,r.cloneElement)(g.filter((e=>e.props.value===C))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},g.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==C})))))}function d(e){const t=(0,i.Z)();return r.createElement(u,(0,a.Z)({key:String(t)},e))}},7207:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>p});var a=n(7462),r=(n(7294),n(3905)),l=n(5488),i=n(5162);const o={sidebar_position:4,title:"Automate secure Kafka access"},s=void 0,c={unversionedId:"quick-tutorials/k8s-kafka-mtls",id:"quick-tutorials/k8s-kafka-mtls",title:"Automate secure Kafka access",description:"This tutorial will walk you through declaring and applying intents to easily secure access to Kafka,",source:"@site/docs/quick-tutorials/k8s-kafka-mtls.mdx",sourceDirName:"quick-tutorials",slug:"/quick-tutorials/k8s-kafka-mtls",permalink:"/quick-tutorials/k8s-kafka-mtls",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/quick-tutorials/k8s-kafka-mtls.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Automate secure Kafka access"},sidebar:"docSidebar",previous:{title:"Map your cluster",permalink:"/quick-tutorials/k8s-network-mapper"},next:{title:"Deploy mTLS between pods",permalink:"/quick-tutorials/k8s-mtls"}},m={},p=[{value:"Install Otterize",id:"install-otterize",level:2},{value:"Install Kafka",id:"install-kafka",level:2},{value:"Manage Kafka access with Otterize",id:"manage-kafka-access-with-otterize",level:2},{value:"Deploy clients",id:"deploy-clients",level:2},{value:"Apply intents",id:"apply-intents",level:2},{value:"What did we accomplish?",id:"what-did-we-accomplish",level:2},{value:"One-time setups:",id:"one-time-setups",level:3},{value:"Per-client setups:",id:"per-client-setups",level:3},{value:"What&#39;s next",id:"whats-next",level:2},{value:"Teardown",id:"teardown",level:2}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This tutorial will walk you through declaring and applying intents to easily secure access to Kafka,\nautomating the generation and deployment of certificates for mTLS and the configuration of ACLs for Kafka."),(0,r.kt)("p",null,"In this tutorial, we will:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Deploy a Kafka broker, and two clients that call it."),(0,r.kt)("li",{parentName:"ul"},"Declare that one client pod intends to access a topic on Kafka."),(0,r.kt)("li",{parentName:"ul"},"See that an ACL was autogenerated to allow just that, while blocking calls from the other client."),(0,r.kt)("li",{parentName:"ul"},"See that mTLS credentials were autogenerated.")),(0,r.kt)("h2",{id:"install-otterize"},"Install Otterize"),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"For this tutorial, we'll disable the network policy component, to focus on the Kafka ACL authorization mechanism.\nIf you already have Otterize installed, redeploy it as shown below. You can always re-enable the network policy component\nlater by deploying it as shown below but without the ",(0,r.kt)("inlineCode",{parentName:"p"},"--set")," flag.")),(0,r.kt)("p",null,"Use Helm to install the latest version of Otterize:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"helm repo add otterize https://helm.otterize.com\nhelm repo update\nhelm install -n otterize-system --create-namespace \\\n--set intentsOperator.operator.enableNetworkPolicyCreation=false otterize otterize/otterize-kubernetes\n")),(0,r.kt)("p",null,"You can add the ",(0,r.kt)("inlineCode",{parentName:"p"},"--wait")," flag for Helm to wait for deployment to complete and all pods to be Ready, or manually watch for all pods to be ",(0,r.kt)("inlineCode",{parentName:"p"},"Ready")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl get pods -n otterize-system -w"),"."),(0,r.kt)("h2",{id:"install-kafka"},"Install Kafka"),(0,r.kt)("p",null,"We will deploy a Kafka cluster using Bitnami's ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bitnami/charts/tree/master/bitnami/kafka"},"Helm chart"),".\nIn the chart we will configure Kafka to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Recognize the Otterize intents operator as a super user so it can configure ACLs;"),(0,r.kt)("li",{parentName:"ul"},"Use TLS (Kafka calls it SSL) for its listeners;"),(0,r.kt)("li",{parentName:"ul"},"Tell the Otterize Credentials operator, via pod annotations, how credentials should be created; and"),(0,r.kt)("li",{parentName:"ul"},"Authenticate clients using mTLS credentials provided as a Kubernetes secret")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Expand to see the Helm values.yaml used with the Bitnami chart"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'# Configure Otterize as a super user to grant it access to configure ACLs\nsuperUsers: "User:CN=kafka.kafka,O=SPIRE,C=US;User:CN=intents-operator-controller-manager.otterize,O=SPIRE,C=US"\n# Use TLS for the Kafka listeners (Kafka calls them SSL)\nlisteners:\n  - "CLIENT://:9092"\n  - "INTERNAL://:9093"\nadvertisedListeners:\n  - "CLIENT://:9092"\n  - "INTERNAL://:9093"\nlistenerSecurityProtocolMap: "INTERNAL:SSL,CLIENT:SSL"\n# Annotations for Otterize to generate credentials\npodAnnotations:\n  credentials-operator.otterize.com/cert-type: jks\n  credentials-operator.otterize.com/tls-secret-name: kafka-tls-secret\n  credentials-operator.otterize.com/truststore-file-name: kafka.truststore.jks\n  credentials-operator.otterize.com/keystore-file-name: kafka-keystore.jks\n  credentials-operator.otterize.com/dns-names: "kafka-0.kafka-headless.kafka.svc.cluster.local,kafka.kafka.svc.cluster.local"\n# Authenticate clients using mTLS\nauth:\n  clientProtocol: mtls\n  interBrokerProtocol: mtls\n  tls:\n    type: jks\n    existingSecrets:\n      - kafka-tls-secret\n    password: password\nauthorizerClassName: kafka.security.authorizer.AclAuthorizer\n# Allocate resources\nresources:\n  requests:\n    cpu: 50m\n    memory: 256Mi\n'))),(0,r.kt)("p",null,"The following command will deploy a Kafka cluster with this chart:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"helm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\nhelm install --create-namespace -n kafka \\\n  -f https://docs.otterize.com/code-examples/kafka-mtls/helm/values.yaml kafka bitnami/kafka\n")),(0,r.kt)("p",null,"You can watch for all pods to be ",(0,r.kt)("inlineCode",{parentName:"p"},"Ready")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl get pods -n kafka -w"),"."),(0,r.kt)("h2",{id:"manage-kafka-access-with-otterize"},"Manage Kafka access with Otterize"),(0,r.kt)("p",null,"Let's connect Kafka with Otterize by applying a ",(0,r.kt)("inlineCode",{parentName:"p"},"KafkaServerConfig"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f https://docs.otterize.com/code-examples/kafka-mtls/kafkaserverconfig.yaml\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Expand to see the KafkaServerConfig"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"kafkaserverconfig.yaml",label:"kafkaserverconfig.yaml",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: k8s.otterize.com/v1alpha2\nkind: KafkaServerConfig\nmetadata:\n  name: kafkaserverconfig\n  namespace: kafka\nspec:\n  service:\n    name: kafka\n  addr: kafka.kafka:9092\n  tls:\n    certFile: /etc/otterize-spire/cert.pem\n    keyFile: /etc/otterize-spire/key.pem\n    rootCAFile: /etc/otterize-spire/ca.pem\n  topics:\n    - topic: "*"\n      pattern: prefix\n      clientIdentityRequired: false\n      intentsRequired: false\n'))))),(0,r.kt)("p",null,"Upon applying the KafkaServerConfig, an ACL will configure Kafka to allow anonymous access all topics.\nThis will be the base state, from which we will gradually roll out secure access to Kafka."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'kubectl logs -n kafka statefulset/kafka | grep "Processing Acl change" | grep ANONYMOUS | tail -n 1\n')),(0,r.kt)("p",null,"You should see the following output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[2022-09-13 10:58:32,052] INFO Processing Acl change notification for\nResourcePattern(resourceType=TOPIC, name=*, patternType=PREFIXED), versionedAcls :\nSet(User:ANONYMOUS has ALLOW permission for operations: ALL from hosts: *,\nUser:* has ALLOW permission for operations: ALL from hosts: *), zkVersion : 0\n(kafka.security.authorizer.AclAuthorizer)\n")),(0,r.kt)("h2",{id:"deploy-clients"},"Deploy clients"),(0,r.kt)("p",null,"Clients will authenticate to Kafka using mTLS. Otterize makes this easy, requiring just 3 simple changes to the client pod spec:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Generate credentials"),": add the ",(0,r.kt)("inlineCode",{parentName:"li"},"credentials-operator.otterize.com/tls-secret-name")," annotation, which tells Otterize to generate mTLS credentials and store them in a Kubernetes secret whose name is the value of this annotation."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Expose credentials in a volume"),": add a volume containing this secret to the pod."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Mount the volume"),": mount the volume in every container in the pod.")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Expand to see this structure"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'spec:\n  template:\n    metadata:\n      annotations:\n        # highlight-next-line\n        # 1. Generate credentials as a secret called "client-credentials-secret":\n        credentials-operator.otterize.com/tls-secret-name: client-credentials-secret\n        ...\n    spec:\n      volumes:\n        # highlight-start\n        # 2. Create a volume containing this secret:\n        - name: otterize-credentials\n          secret:\n            secretName: client-credentials-secret\n        # highlight-end\n        ...\n      containers:\n        - name: client\n          ...\n          volumeMounts:\n            # highlight-start\n            # 3. Mount volume into container\n            - name: otterize-credentials\n              mountPath: /var/otterize/credentials\n              readOnly: true\n            # highlight-end\n'))),(0,r.kt)("p",null,"Our simple example consists of a two client pods ","\u2014",' "client" and "client-other" ',"\u2014"," and the Kafka broker."),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Expand to see the client specs used in this example"),(0,r.kt)(l.Z,{mdxType:"Tabs"},(0,r.kt)(i.Z,{value:"namespace.yaml",label:"namespace.yaml",default:!0,mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Namespace\nmetadata:\n  name: otterize-tutorial-kafka-mtls\n"))),(0,r.kt)(i.Z,{value:"client-deployment.yaml",label:"client-deployment.yaml",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myclient\n  namespace: otterize-tutorial-kafka-mtls\nspec:\n  selector:\n    matchLabels:\n      app: myclient\n  template:\n    metadata:\n      labels:\n        app: myclient\n      annotations:\n        credentials-operator.otterize.com/tls-secret-name: myclient-credentials-secret\n    spec:\n      containers:\n        - name: myclient\n          image: golang\n          command: [ "/bin/sh", "-c", "--" ]\n          args: [ "while true; do cd /app; cp src/* .; go get main; go run .; sleep infinity; done" ]\n          volumeMounts:\n            - name: ephemeral\n              mountPath: /app\n            - mountPath: /app/src\n              name: myclient-go\n            - name: otterize-credentials\n              mountPath: /var/otterize/credentials\n              readOnly: true\n      volumes:\n        - name: myclient-go\n          configMap:\n            name: myclient-go\n        - name: otterize-credentials\n          secret:\n            secretName: myclient-credentials-secret\n        - name: ephemeral\n          emptyDir: { }\n'))),(0,r.kt)(i.Z,{value:"client-configmap.yaml",label:"client-configmap.yaml",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: myclient-go\n  namespace: otterize-tutorial-kafka-mtls\ndata:\n  myclient.go: |\n    package main\n    \n    import (\n        "crypto/tls"\n        "crypto/x509"\n        "fmt"\n        "github.com/Shopify/sarama"\n        "github.com/sirupsen/logrus"\n        "io/ioutil"\n        "time"\n    )\n    \n    const (\n        kafkaAddr = "kafka.kafka:9092"\n        testTopicName = "mytopic"\n        certFile = "/var/otterize/credentials/cert.pem"\n        keyFile = "/var/otterize/credentials/key.pem"\n        rootCAFile = "/var/otterize/credentials/ca.pem"\n    )\n    \n    func getTLSConfig()( * tls.Config, error) {\n        cert, err: = tls.LoadX509KeyPair(certFile, keyFile)\n        if err != nil {\n            return nil, fmt.Errorf("failed loading x509 key pair: %w", err)\n        }\n    \n        pool: = x509.NewCertPool()\n        rootCAPEM, err: = ioutil.ReadFile(rootCAFile)\n        if err != nil {\n            return nil, fmt.Errorf("failed loading root CA PEM file: %w ", err)\n        }\n        pool.AppendCertsFromPEM(rootCAPEM)\n    \n        return &tls.Config {\n            Certificates: [] tls.Certificate {\n                cert\n            },\n            RootCAs: pool,\n        }, nil\n    }\n    \n    func send_messages(producer sarama.SyncProducer) {\n        i: = 1\n        for {\n            msg: = fmt.Sprintf("Message %d [sent by client]", i)\n            _,\n            _,\n            err: = producer.SendMessage( & sarama.ProducerMessage {\n                Topic: testTopicName,\n                Partition: -1,\n                Value: sarama.StringEncoder(msg),\n            })\n            if err != nil {\n                return\n            }\n            fmt.Printf("Sent message - %s\\n", msg)\n            time.Sleep(2 * time.Second)\n            i++\n        }\n    }\n    \n    func loop_kafka() error {\n        addrs: = [] string {\n            kafkaAddr\n        }\n    \n            config: = sarama.NewConfig()\n        fmt.Println("Loading mTLS certificates")\n        config.Net.TLS.Enable = true\n        tlsConfig,\n        err: = getTLSConfig()\n        if err != nil {\n            return err\n        }\n        config.Net.TLS.Config = tlsConfig\n        fmt.Println("Connecting to Kafka")\n        config.Net.DialTimeout = 5 * time.Second\n        config.Net.ReadTimeout = 5 * time.Second\n        config.Net.WriteTimeout = 5 * time.Second\n        client,\n        err: = sarama.NewClient(addrs, config)\n        if err != nil {\n            return err\n        }\n        fmt.Println("Creating a producer and a consumer for -", testTopicName)\n        config.Producer.Return.Successes = true\n        config.Producer.Timeout = 5 * time.Second\n        config.Consumer.MaxWaitTime = 5 * time.Second\n        config.Producer.Return.Errors = true\n        config.Consumer.Return.Errors = true\n        producer,\n        err: = sarama.NewSyncProducerFromClient(client)\n        if err != nil {\n            return err\n        }\n    \n        consumer,\n        err: = sarama.NewConsumerFromClient(client)\n        if err != nil {\n            return err\n        }\n        fmt.Println("Sending messages")\n        go send_messages(producer)\n    \n        partConsumer,\n        err: = consumer.ConsumePartition(testTopicName, 0, 0)\n        if err != nil {\n            return err\n        }\n    \n        for msg: = range partConsumer.Messages() {\n            fmt.Printf("Read message - %s\\n", msg.Value)\n        }\n        return nil\n    }\n    \n    func main() {\n        for {\n            err: = loop_kafka()\n            logrus.WithError(err).Println()\n            fmt.Println("Loop exited")\n            time.Sleep(2 * time.Second)\n        }\n    }\n'))),(0,r.kt)(i.Z,{value:"client-other-deployment.yaml",label:"client-other-deployment.yaml",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myclient-other\n  namespace: otterize-tutorial-kafka-mtls\nspec:\n  selector:\n    matchLabels:\n      app: myclient-other\n  template:\n    metadata:\n      labels:\n        app: myclient-other\n      annotations:\n        credentials-operator.otterize.com/tls-secret-name: myclient-other-credentials-secret\n    spec:\n      containers:\n        - name: myclient-other\n          image: golang\n          command: [ "/bin/sh", "-c", "--" ]\n          args: [ "while true; do cd /app; cp src/* .; go get main; go run .; sleep infinity; done" ]\n          volumeMounts:\n            - name: ephemeral\n              mountPath: /app\n            - mountPath: /app/src\n              name: myclient-other-go\n            - name: otterize-credentials\n              mountPath: /var/otterize/credentials\n              readOnly: true\n      volumes:\n        - name: myclient-other-go\n          configMap:\n            name: myclient-other-go\n        - name: otterize-credentials\n          secret:\n            secretName: myclient-other-credentials-secret\n        - name: ephemeral\n          emptyDir: { }\n'))),(0,r.kt)(i.Z,{value:"client-other-configmap.yaml",label:"client-other-configmap.yaml",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: myclient-other-go\n  namespace: otterize-tutorial-kafka-mtls\ndata:\n  myclient-other.go: |\n    package main\n    \n    import (\n        "crypto/tls"\n        "crypto/x509"\n        "fmt"\n        "github.com/Shopify/sarama"\n        "github.com/sirupsen/logrus"\n        "io/ioutil"\n        "time"\n    )\n    \n    const (\n        kafkaAddr = "kafka.kafka:9092"\n        testTopicName = "mytopic"\n        certFile = "/var/otterize/credentials/cert.pem"\n        keyFile = "/var/otterize/credentials/key.pem"\n        rootCAFile = "/var/otterize/credentials/ca.pem"\n    )\n    \n    func getTLSConfig()( * tls.Config, error) {\n        cert, err: = tls.LoadX509KeyPair(certFile, keyFile)\n        if err != nil {\n            return nil, fmt.Errorf("failed loading x509 key pair: %w", err)\n        }\n    \n        pool: = x509.NewCertPool()\n        rootCAPEM, err: = ioutil.ReadFile(rootCAFile)\n        if err != nil {\n            return nil, fmt.Errorf("failed loading root CA PEM file: %w ", err)\n        }\n        pool.AppendCertsFromPEM(rootCAPEM)\n    \n        return &tls.Config {\n            Certificates: [] tls.Certificate {\n                cert\n            },\n            RootCAs: pool,\n        }, nil\n    }\n    \n    func loop_kafka() error {\n        addrs: = [] string {\n            kafkaAddr\n        }\n    \n            config: = sarama.NewConfig()\n        fmt.Println("Loading mTLS certificates")\n        config.Net.TLS.Enable = true\n        tlsConfig,\n        err: = getTLSConfig()\n        if err != nil {\n            return err\n        }\n        config.Net.TLS.Config = tlsConfig\n        fmt.Println("Connecting to Kafka")\n        config.Net.DialTimeout = 5 * time.Second\n        config.Net.ReadTimeout = 5 * time.Second\n        config.Net.WriteTimeout = 5 * time.Second\n        client,\n        err: = sarama.NewClient(addrs, config)\n        if err != nil {\n            return err\n        }\n        fmt.Println("Creating a producer for -", testTopicName)\n        config.Producer.Return.Successes = true\n        config.Producer.Timeout = 5 * time.Second\n        config.Producer.Return.Errors = true\n        producer,\n        err: = sarama.NewSyncProducerFromClient(client)\n        if err != nil {\n            return err\n        }\n    \n        fmt.Println("Sending messages")\n        i: = 1\n        for {\n            msg: = fmt.Sprintf("Message %d [sent by client-other]", i)\n            _,\n            _,\n            err = producer.SendMessage( & sarama.ProducerMessage {\n                Topic: testTopicName,\n                Partition: -1,\n                Value: sarama.StringEncoder(msg),\n            })\n            if err != nil {\n                return err\n            }\n            fmt.Printf("Sent message - %s\\n", msg)\n            time.Sleep(1 * time.Second)\n            i++\n        }\n    \n        return nil\n    }\n    \n    func main() {\n        for {\n            err: = loop_kafka()\n            logrus.WithError(err).Println()\n            fmt.Println("Loop exited")\n            time.Sleep(2 * time.Second)\n        }\n    }\n'))))),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Deploy the two clients into a namespace called ",(0,r.kt)("inlineCode",{parentName:"li"},"otterize-tutorial-kafka-mtls")," using ",(0,r.kt)("inlineCode",{parentName:"li"},"kubectl"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f https://docs.otterize.com/code-examples/kafka-mtls/all.yaml\n")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Optional: check deployment status"),(0,r.kt)("p",null,"Check that the client pods were deployed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -n otterize-tutorial-kafka-mtls\n")),(0,r.kt)("p",null,"You should see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME                              READY   STATUS    RESTARTS   AGE\nmyclient-5d9646fc46-tw5hs         1/1     Running   0          21s\nmyclient-other-59647b448c-w4cpq   1/1     Running   0          21s\n"))),(0,r.kt)("p",null,"Let's monitor, in separate terminal windows, both clients' attempts to call Kafka,\nso we can see the effects of our changes in real time."),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Open a new terminal window ","[myclient]")," and tail the client log:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl logs -f --tail 1 -n otterize-tutorial-kafka-mtls deploy/myclient\n")),(0,r.kt)("p",null,"This client should be able to communicate with the server:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Loading mTLS certificates\nConnecting to Kafka\nCreating a producer and a consumer for - mytopic\nSending messages\nSent message - Message 1 [sent by client]\nRead message - Message 1 [sent by client]\nRead message - Message 1 [sent by client-other]\nSent message - Message 2 [sent by client]\nRead message - Message 2 [sent by client-other]\nRead message - Message 2 [sent by client]\nRead message - Message 3 [sent by client-other]\nSent message - Message 3 [sent by client]\nRead message - Message 3 [sent by client]\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Open another terminal window ","[myclient-other]")," and tail the client-other log:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl logs -f --tail 1 -n otterize-tutorial-kafka-mtls deploy/myclient-other\n")),(0,r.kt)("p",null,"This other client should also be able to communicate with the server:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Loading mTLS certificates\nConnecting to Kafka\nCreating a producer for - mytopic\nSending messages\nSent message - Message 1 [sent by client-other]\nSent message - Message 2 [sent by client-other]\nSent message - Message 3 [sent by client-other]\n")),(0,r.kt)("h2",{id:"apply-intents"},"Apply intents"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The client declares its intent to call the server with this ",(0,r.kt)("inlineCode",{parentName:"li"},"intents.yaml")," file:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: k8s.otterize.com/v1alpha2\nkind: ClientIntents\nmetadata:\n  name: myclient\n  namespace:  otterize-tutorial-kafka-mtls\nspec:\n  service:\n    name: myclient\n  calls:\n    - name: kafka.kafka\n      type: kafka\n      topics:\n        - name: mytopic\n          operations: [ all ]\n\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Client intents are the cornerstone of ",(0,r.kt)("a",{parentName:"p",href:"https://otterize.com/ibac"},"intent-based access control"),".")),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Keep an eye on the logs being tailed in the ",(0,r.kt)("strong",{parentName:"li"},"[client-other]")," while you apply this ",(0,r.kt)("inlineCode",{parentName:"li"},"intents.yaml")," file in your ",(0,r.kt)("strong",{parentName:"li"},"main terminal window")," using:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f https://docs.otterize.com/code-examples/kafka-mtls/client-intents.yaml\n")),(0,r.kt)("p",null,"You should quickly see in the ",(0,r.kt)("strong",{parentName:"p"},"[client-other]")," that the ",(0,r.kt)("strong",{parentName:"p"},"other client cannot")," access the topic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Sent message - Message 12 [sent by client-other]            # <- before applying the intents file\nSent message - Message 13 [sent by client-other]            # <- before applying the intents file\ntime="2022-10-06T09:44:53Z" level=info error="kafka server: # <- after applying the intents file\n The client is not authorized to access this topic"\nLoop exited\n')),(0,r.kt)("p",null,"Meanwhile, in the ",(0,r.kt)("strong",{parentName:"p"},"[client]")," terminal you can see that the ",(0,r.kt)("strong",{parentName:"p"},"client can")," access the topic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Sent message - Message 24 [sent by client]\nRead message - Message 24 [sent by client]\nSent message - Message 25 [sent by client]\nRead message - Message 25 [sent by client]\n")),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"Verify that an ACL for this client was configured on the Kafka broker:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'kubectl logs -n kafka statefulset/kafka | grep "Processing Acl change" | grep mytopic | tail -n 1\n')),(0,r.kt)("p",null,"You should see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"[2022-09-13 10:44:52,803] INFO Processing Acl change notification for\nResourcePattern(resourceType=TOPIC, name=mytopic, patternType=LITERAL),\nversionedAcls : Set(User:ANONYMOUS has DENY permission for operations:\nALL from hosts: *, User:CN=myclient.otterize-tutorial-kafka-mtls,O=SPIRE,C=US has ALLOW permission\nfor operations: ALL from hosts: *), zkVersion : 6 (kafka.security.authorizer.AclAuthorizer)\n")),(0,r.kt)("h2",{id:"what-did-we-accomplish"},"What did we accomplish?"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Controlling Kafka access no longer means touching ACLs, issuing and managing and distributing certs, establishing trust,\netc.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"As we saw with pod-to-pod access, clients simply declare with their intents files the Kafka access they need,\nand define a place on their filesystem where they'll get the appropriate credentials (certs).")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The next ",(0,r.kt)("inlineCode",{parentName:"p"},"kubectl apply")," ensures that all the appropriate certs are issued and distributed,\nand that Kafka ACLs are configured to reflect precisely the intended topic-level access."))),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Expand to see what happened behind the scenes"),(0,r.kt)("h3",{id:"one-time-setups"},"One-time setups:"),(0,r.kt)("p",null,"We configured the Helm chart for Kafka to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Allow the Otterize intents operator to be a Kafka super user (authenticated with a certificate)."),(0,r.kt)("li",{parentName:"ul"},"Use the SSL protocol for the Kafka listeners."),(0,r.kt)("li",{parentName:"ul"},"Let Otterize know it should generate mTLS credentials in the Java Key Store and Java Trust Store formats, and store them as a Kubernetes secret."),(0,r.kt)("li",{parentName:"ul"},"Use mTLS to authenticate clients, using this Kubernetes secret.")),(0,r.kt)("p",null,"We configured Kafka itself to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Add the TLS certificates of the Otterize Credentials operator."),(0,r.kt)("li",{parentName:"ul"},"Set the default ACL for all topics to allow anonymous access.")),(0,r.kt)("h3",{id:"per-client-setups"},"Per-client setups:"),(0,r.kt)("p",null,"We configured each of our clients to:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Let Otterize know it should generate mTLS credentials for that client."),(0,r.kt)("li",{parentName:"ul"},"Mount the Kubernetes secret in a local volume.")),(0,r.kt)("p",null,"This already enables mTLS authentication between both clients and Kafka."),(0,r.kt)("p",null,"Then we applied intents:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We only declared that the ",(0,r.kt)("em",{parentName:"li"},"client")," pod (not the ",(0,r.kt)("em",{parentName:"li"},"client-other")," pod) needed to access the ",(0,r.kt)("inlineCode",{parentName:"li"},"mytopic")," topic.")),(0,r.kt)("p",null,"This allowed the ",(0,r.kt)("em",{parentName:"p"},"client")," pod its access and protected ",(0,r.kt)("inlineCode",{parentName:"p"},"mytopic")," from any unintended access, such as from ",(0,r.kt)("em",{parentName:"p"},"client-other"),".")),(0,r.kt)("admonition",{title:"Bonus tutorial",type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Try to create an intents file yourself for ",(0,r.kt)("strong",{parentName:"p"},"client-other"),", and apply it to allow this other client to access the topic.")),(0,r.kt)("h2",{id:"whats-next"},"What's next"),(0,r.kt)("p",null,"Take a realistic ecommerce application with multiple services for a spin and learn how to manage it with"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/realistic-example/shadow-mode-network-policies"},"Network policies")," - use shadow mode to boost confidence when rolling out secure access."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/realistic-example/visualize-kafka-protection"},"Secure access to Kafka")," - visualize kafka configuration and changes.")),(0,r.kt)("h2",{id:"teardown"},"Teardown"),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Take care to remove the intents before removing the KafkaServerConfig or the Kafka broker, as the operator will not know how to remove\nthe intents if you first make it forget about the Kafka broker or it can't access the broker.\nIf it's unable to remove the ACLs for the intents, the operator will prevent the intents from being deleted until\nit is able to do so.")),(0,r.kt)("p",null,"To remove the deployed examples run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# run this first:\nkubectl delete -f https://docs.otterize.com/code-examples/kafka-mtls/client-intents.yaml\n# then the rest:\nkubectl delete -f https://docs.otterize.com/code-examples/kafka-mtls/all.yaml\nkubectl delete -f https://docs.otterize.com/code-examples/kafka-mtls/kafkaserverconfig.yaml\nhelm uninstall kafka -n kafka\n")))}d.isMDXComponent=!0}}]);