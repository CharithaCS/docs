"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[400],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=a,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||o;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9472:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={sidebar_position:2,title:"Intents operator"},i=void 0,s={unversionedId:"components/intents-operator/README",id:"components/intents-operator/README",title:"Intents operator",description:"The Otterize intents operator is an open source Kubernetes operator for easily managing service-to-service authorization",source:"@site/docs/components/intents-operator/README.mdx",sourceDirName:"components/intents-operator",slug:"/components/intents-operator/",permalink:"/components/intents-operator/",draft:!1,editUrl:"https://github.com/otterize/docs/edit/main/docs/components/intents-operator/README.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Intents operator"},sidebar:"docSidebar",previous:{title:"Otterize OSS Helm chart",permalink:"/components/otterize-chart/"},next:{title:"Helm chart",permalink:"/components/intents-operator/helm-chart"}},l={},c=[{value:"Deploying the intents operator",id:"deploying-the-intents-operator",level:2},{value:"Controlling access using the intents operator",id:"controlling-access-using-the-intents-operator",level:2},{value:"Pod annotations",id:"pod-annotations",level:2},{value:"Supported enforcement types",id:"supported-enforcement-types",level:2},{value:"Network policies",id:"network-policies",level:3},{value:"Handling external traffic",id:"handling-external-traffic",level:4},{value:"Kafka mTLS &amp; ACLs",id:"kafka-mtls--acls",level:3},{value:"ACL creation and consumer groups",id:"acl-creation-and-consumer-groups",level:4}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The Otterize intents operator is an open source Kubernetes operator for easily managing service-to-service authorization\nby declaring the calls each service needs to make, using ",(0,a.kt)("a",{parentName:"p",href:"/intent-based-access-control"},"client intents files"),".\nThe intents operator uses these files to configure network policies, Kafka ACLs, and other enforcement points (in the future) to allow just the intended calls."),(0,a.kt)("p",null,"If credentials such as X.509 certificates are needed for authentication ","\u2014"," for example,\nto connect to Kafka using mTLS ","\u2014"," the Otterize intents operator works with SPIRE via the\n",(0,a.kt)("a",{parentName:"p",href:"/components/spire-integration-operator"},"SPIRE integration operator")," to automatically:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Establish pod service identities."),(0,a.kt)("li",{parentName:"ul"},"Generate trusted credentials for each client service."),(0,a.kt)("li",{parentName:"ul"},"Deliver the credentials to the pod's containers within a locally-mounted volume.")),(0,a.kt)("h2",{id:"deploying-the-intents-operator"},"Deploying the intents operator"),(0,a.kt)("p",null,"To deploy the operator, ",(0,a.kt)("a",{parentName:"p",href:"/components/intents-operator/helm-chart"},"use the Helm chart"),"."),(0,a.kt)("h2",{id:"controlling-access-using-the-intents-operator"},"Controlling access using the intents operator"),(0,a.kt)("p",null,"To learn how to use the intents operator to control access, consult the guides for ",(0,a.kt)("a",{parentName:"p",href:"/guides/k8s-ibac-via-network-policies"},"managing network policies using intents")," and ",(0,a.kt)("a",{parentName:"p",href:"/guides/ibac-for-k8s-kafka"},"Kafka ACLs using intents"),"."),(0,a.kt)("h2",{id:"pod-annotations"},"Pod annotations"),(0,a.kt)("p",null,"You can override the service name the intents operator uses when it computes network policies and Kafka ACLs with a pod annotation."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Annotation"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"),(0,a.kt)("th",{parentName:"tr",align:null},"Default"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"intents.otterize.com/service-name")),(0,a.kt)("td",{parentName:"tr",align:null},"Otterize-wide override for this service's name. Used by the operator when computing a pod's service name for use in network policies and Kafka ACLs."),(0,a.kt)("td",{parentName:"tr",align:null},"See ",(0,a.kt)("a",{parentName:"td",href:"/service-identities"},"Service identities"))))),(0,a.kt)("h2",{id:"supported-enforcement-types"},"Supported enforcement types"),(0,a.kt)("h3",{id:"network-policies"},"Network policies"),(0,a.kt)("p",null,"The intents operator automatically creates, updates and deletes network policies, and automatically labels client and server pods, to reflect precisely the client-to-server calls declared in client intents files."),(0,a.kt)("p",null,"In the example above, the ",(0,a.kt)("inlineCode",{parentName:"p"},"checkoutservice")," intends to call the ",(0,a.kt)("inlineCode",{parentName:"p"},"shippingservice"),". When the CRD is applied through ",(0,a.kt)("inlineCode",{parentName:"p"},"kubectl apply"),", the intents operator labels the ",(0,a.kt)("inlineCode",{parentName:"p"},"checkoutservice")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"shippingservice")," pods, and creates a network policy for the ingress of the ",(0,a.kt)("inlineCode",{parentName:"p"},"shippingservice")," that references these labels and allows calls to the ",(0,a.kt)("inlineCode",{parentName:"p"},"shippingservice")," from the ",(0,a.kt)("inlineCode",{parentName:"p"},"checkoutservice"),"."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"/service-identities"},"Service identities and resolution")," to learn how service names are resolved for pods."),(0,a.kt)("p",null,"The intents operator then uses the resolved identity as the service name, and combines it with the namespace of the pod and hashed to form the value of the label ",(0,a.kt)("inlineCode",{parentName:"p"},"intents.otterize.com/server"),".\nThis label is then used as a selector for network policies. Another\nlabel, ",(0,a.kt)("inlineCode",{parentName:"p"},"intents.otterize.com/access-server-<servicename>-<servicehash>"),", is applied to client pods which have declared their intent\nto access the server. This label is used as the selector to determine which client pods are allowed to access the server\npod."),(0,a.kt)("h4",{id:"handling-external-traffic"},"Handling external traffic"),(0,a.kt)("p",null,"The intents operator has automatic behavior for allowing external traffic for pods which have indicated that they are supposed to accept external traffic, such as by creating a ",(0,a.kt)("inlineCode",{parentName:"p"},"Service")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"NodePort")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"LoadBalancer"),", or an ",(0,a.kt)("inlineCode",{parentName:"p"},"Ingress")," resource."),(0,a.kt)("p",null,"As the intents operator creates network policies, and the semantics of network policies dictate that:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"if no network policies apply to a pod, then all traffic is allowed."),(0,a.kt)("li",{parentName:"ol"},"once any network policy applies to a pod, only the traffic explicitly allowed in the policy is allowed")),(0,a.kt)("p",null,"This meant that if you had no network policies on a pod, and created ClientIntents for that pod, then external traffic would be blocked. To make it easy to enable pod-to-pod traffic without affecting expected external traffic, the intents operator automatically detects resources of kind ",(0,a.kt)("inlineCode",{parentName:"p"},"Service")," of type ",(0,a.kt)("inlineCode",{parentName:"p"},"NodePort")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"LoadBalancer"),", or an ",(0,a.kt)("inlineCode",{parentName:"p"},"Ingress")," resource, and if it creates the first network policy to affect those pods, it also creates a network policy that allows external traffic to those pods, as specified by the external ",(0,a.kt)("inlineCode",{parentName:"p"},"Service"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"Ingress")," - for example, it only allows traffic to the specified ports, not all traffic."),(0,a.kt)("p",null,"This behavior can be disabled using the Helm chart's values."),(0,a.kt)("h3",{id:"kafka-mtls--acls"},"Kafka mTLS & ACLs"),(0,a.kt)("p",null,"The intents operator automatically creates, updates, and deletes ACLs in Kafka clusters running within your Kubernetes cluster according to the declared intents. It does not modify other ACLs. It works together with SPIRE and the ",(0,a.kt)("a",{parentName:"p",href:"/components/spire-integration-operator"},"Otterize SPIRE integration operator")," to easily enable secure access to Kafka from client pods, all in your Kubernetes cluster."),(0,a.kt)("p",null,"The Otterize SPIRE integration operator automatically registers client pods with a SPIRE server, and writes the trusted credentials generated by SPIRE into Kubernetes secrets for use by those pods. The intents operator takes ",(0,a.kt)("inlineCode",{parentName:"p"},"ClientIntents")," with ",(0,a.kt)("inlineCode",{parentName:"p"},"type: kafka")," and creates Kafka ACLs that grant the requested access to the cryptographic identities (SVIDs) created by the SPIRE integration operator."),(0,a.kt)("h4",{id:"acl-creation-and-consumer-groups"},"ACL creation and consumer groups"),(0,a.kt)("p",null,"A Kafka client may specify a consumer group ID when consuming a topic. When it does so, it requires DESCRIBE and READ access to the consumer group resource.\nTo enable this, the intents operator creates an ACL enabling all consumers to read and describe all consumer groups.\nThe permission check performed by the AclAuthorizer for a consumer group also takes into account whether the consumer has the appropriate access to the topic\nit is attempting to read, so the end result is that the topic ACLs determine actual access."))}d.isMDXComponent=!0}}]);